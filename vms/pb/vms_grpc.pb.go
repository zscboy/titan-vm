// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v4.25.7
// source: vms.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Vms_CreateVMWithLibvirt_FullMethodName               = "/pb.Vms/CreateVMWithLibvirt"
	Vms_CreateVolWithLibvirt_FullMethodName              = "/pb.Vms/CreateVolWithLibvirt"
	Vms_GetVol_FullMethodName                            = "/pb.Vms/GetVol"
	Vms_AddNetworkInterfaceWithLibvirt_FullMethodName    = "/pb.Vms/AddNetworkInterfaceWithLibvirt"
	Vms_DeleteNetworkInterfaceWithLibvirt_FullMethodName = "/pb.Vms/DeleteNetworkInterfaceWithLibvirt"
	Vms_AddDiskWithLibvirt_FullMethodName                = "/pb.Vms/AddDiskWithLibvirt"
	Vms_DeleteDiskWithLibvirt_FullMethodName             = "/pb.Vms/DeleteDiskWithLibvirt"
	Vms_AddHostdevWithLibvirt_FullMethodName             = "/pb.Vms/AddHostdevWithLibvirt"
	Vms_DeleteHostdevWithLibvirt_FullMethodName          = "/pb.Vms/DeleteHostdevWithLibvirt"
	Vms_GetVncPortWithLibvirt_FullMethodName             = "/pb.Vms/GetVncPortWithLibvirt"
	Vms_ReinstallVMWithLibvirt_FullMethodName            = "/pb.Vms/ReinstallVMWithLibvirt"
	Vms_CreateVM_FullMethodName                          = "/pb.Vms/CreateVM"
	Vms_StartVM_FullMethodName                           = "/pb.Vms/StartVM"
	Vms_StopVM_FullMethodName                            = "/pb.Vms/StopVM"
	Vms_DeleteVM_FullMethodName                          = "/pb.Vms/DeleteVM"
	Vms_ListVMInstance_FullMethodName                    = "/pb.Vms/ListVMInstance"
	Vms_ListImage_FullMethodName                         = "/pb.Vms/ListImage"
	Vms_DeleteImage_FullMethodName                       = "/pb.Vms/DeleteImage"
	Vms_UpdateVM_FullMethodName                          = "/pb.Vms/UpdateVM"
	Vms_GetVMInfo_FullMethodName                         = "/pb.Vms/GetVMInfo"
	Vms_CreateVMWithMultipass_FullMethodName             = "/pb.Vms/CreateVMWithMultipass"
	Vms_MultipassExec_FullMethodName                     = "/pb.Vms/MultipassExec"
	Vms_ListNode_FullMethodName                          = "/pb.Vms/ListNode"
	Vms_GetNode_FullMethodName                           = "/pb.Vms/GetNode"
)

// VmsClient is the client API for Vms service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VmsClient interface {
	// Libvirt
	CreateVMWithLibvirt(ctx context.Context, in *CreateVMWithLibvirtRequest, opts ...grpc.CallOption) (*VMOperationResponse, error)
	CreateVolWithLibvirt(ctx context.Context, in *CreateVolWithLibvirtReqeust, opts ...grpc.CallOption) (*CreateVolWithLibvirtResponse, error)
	GetVol(ctx context.Context, in *GetVolRequest, opts ...grpc.CallOption) (*GetVolResponse, error)
	// rpc ListHostNetworkInterfaceWithLibvirt(ListHostNetworkInterfaceRequest) returns (ListHostNetworkInterfaceResponse);
	// rpc ListVMNetwrokInterfaceWithLibvirt(ListVMNetwrokInterfaceReqeust) returns (ListVMNetworkInterfaceResponse);
	AddNetworkInterfaceWithLibvirt(ctx context.Context, in *AddNetworkInterfaceRequest, opts ...grpc.CallOption) (*VMOperationResponse, error)
	DeleteNetworkInterfaceWithLibvirt(ctx context.Context, in *DeleteNetworkInterfaceRequest, opts ...grpc.CallOption) (*VMOperationResponse, error)
	AddDiskWithLibvirt(ctx context.Context, in *AddDiskRequest, opts ...grpc.CallOption) (*VMOperationResponse, error)
	DeleteDiskWithLibvirt(ctx context.Context, in *DeleteDiskRequest, opts ...grpc.CallOption) (*VMOperationResponse, error)
	AddHostdevWithLibvirt(ctx context.Context, in *AddHostdevRequest, opts ...grpc.CallOption) (*VMOperationResponse, error)
	DeleteHostdevWithLibvirt(ctx context.Context, in *DeleteHostdevRequest, opts ...grpc.CallOption) (*VMOperationResponse, error)
	GetVncPortWithLibvirt(ctx context.Context, in *VMVncPortRequest, opts ...grpc.CallOption) (*VMVncPortResponse, error)
	ReinstallVMWithLibvirt(ctx context.Context, in *ReinstallVMRequest, opts ...grpc.CallOption) (*VMOperationResponse, error)
	// common
	CreateVM(ctx context.Context, in *CreateVMRequest, opts ...grpc.CallOption) (*VMOperationResponse, error)
	StartVM(ctx context.Context, in *StartVMRequest, opts ...grpc.CallOption) (*VMOperationResponse, error)
	StopVM(ctx context.Context, in *StopVMRequest, opts ...grpc.CallOption) (*VMOperationResponse, error)
	DeleteVM(ctx context.Context, in *DeleteVMRequest, opts ...grpc.CallOption) (*VMOperationResponse, error)
	ListVMInstance(ctx context.Context, in *ListVMInstanceReqeust, opts ...grpc.CallOption) (*ListVMInstanceResponse, error)
	ListImage(ctx context.Context, in *ListImageRequest, opts ...grpc.CallOption) (*ListImageResponse, error)
	DeleteImage(ctx context.Context, in *DeleteImageRequest, opts ...grpc.CallOption) (*DeleteImageResponse, error)
	// not implement now
	UpdateVM(ctx context.Context, in *UpdateVMRequest, opts ...grpc.CallOption) (*VMOperationResponse, error)
	GetVMInfo(ctx context.Context, in *GetVMInfoRequest, opts ...grpc.CallOption) (*GetVMInfoResponse, error)
	// Multipass
	CreateVMWithMultipass(ctx context.Context, in *CreateVMWithMultipassRequest, opts ...grpc.CallOption) (*VMOperationResponse, error)
	MultipassExec(ctx context.Context, in *MultipassExecRequest, opts ...grpc.CallOption) (*MultipassExecResponse, error)
	// node
	ListNode(ctx context.Context, in *ListNodeRequest, opts ...grpc.CallOption) (*ListNodeResponse, error)
	GetNode(ctx context.Context, in *GetNodeRequest, opts ...grpc.CallOption) (*GetNodeResponse, error)
}

type vmsClient struct {
	cc grpc.ClientConnInterface
}

func NewVmsClient(cc grpc.ClientConnInterface) VmsClient {
	return &vmsClient{cc}
}

func (c *vmsClient) CreateVMWithLibvirt(ctx context.Context, in *CreateVMWithLibvirtRequest, opts ...grpc.CallOption) (*VMOperationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VMOperationResponse)
	err := c.cc.Invoke(ctx, Vms_CreateVMWithLibvirt_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vmsClient) CreateVolWithLibvirt(ctx context.Context, in *CreateVolWithLibvirtReqeust, opts ...grpc.CallOption) (*CreateVolWithLibvirtResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateVolWithLibvirtResponse)
	err := c.cc.Invoke(ctx, Vms_CreateVolWithLibvirt_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vmsClient) GetVol(ctx context.Context, in *GetVolRequest, opts ...grpc.CallOption) (*GetVolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetVolResponse)
	err := c.cc.Invoke(ctx, Vms_GetVol_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vmsClient) AddNetworkInterfaceWithLibvirt(ctx context.Context, in *AddNetworkInterfaceRequest, opts ...grpc.CallOption) (*VMOperationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VMOperationResponse)
	err := c.cc.Invoke(ctx, Vms_AddNetworkInterfaceWithLibvirt_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vmsClient) DeleteNetworkInterfaceWithLibvirt(ctx context.Context, in *DeleteNetworkInterfaceRequest, opts ...grpc.CallOption) (*VMOperationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VMOperationResponse)
	err := c.cc.Invoke(ctx, Vms_DeleteNetworkInterfaceWithLibvirt_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vmsClient) AddDiskWithLibvirt(ctx context.Context, in *AddDiskRequest, opts ...grpc.CallOption) (*VMOperationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VMOperationResponse)
	err := c.cc.Invoke(ctx, Vms_AddDiskWithLibvirt_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vmsClient) DeleteDiskWithLibvirt(ctx context.Context, in *DeleteDiskRequest, opts ...grpc.CallOption) (*VMOperationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VMOperationResponse)
	err := c.cc.Invoke(ctx, Vms_DeleteDiskWithLibvirt_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vmsClient) AddHostdevWithLibvirt(ctx context.Context, in *AddHostdevRequest, opts ...grpc.CallOption) (*VMOperationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VMOperationResponse)
	err := c.cc.Invoke(ctx, Vms_AddHostdevWithLibvirt_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vmsClient) DeleteHostdevWithLibvirt(ctx context.Context, in *DeleteHostdevRequest, opts ...grpc.CallOption) (*VMOperationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VMOperationResponse)
	err := c.cc.Invoke(ctx, Vms_DeleteHostdevWithLibvirt_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vmsClient) GetVncPortWithLibvirt(ctx context.Context, in *VMVncPortRequest, opts ...grpc.CallOption) (*VMVncPortResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VMVncPortResponse)
	err := c.cc.Invoke(ctx, Vms_GetVncPortWithLibvirt_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vmsClient) ReinstallVMWithLibvirt(ctx context.Context, in *ReinstallVMRequest, opts ...grpc.CallOption) (*VMOperationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VMOperationResponse)
	err := c.cc.Invoke(ctx, Vms_ReinstallVMWithLibvirt_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vmsClient) CreateVM(ctx context.Context, in *CreateVMRequest, opts ...grpc.CallOption) (*VMOperationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VMOperationResponse)
	err := c.cc.Invoke(ctx, Vms_CreateVM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vmsClient) StartVM(ctx context.Context, in *StartVMRequest, opts ...grpc.CallOption) (*VMOperationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VMOperationResponse)
	err := c.cc.Invoke(ctx, Vms_StartVM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vmsClient) StopVM(ctx context.Context, in *StopVMRequest, opts ...grpc.CallOption) (*VMOperationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VMOperationResponse)
	err := c.cc.Invoke(ctx, Vms_StopVM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vmsClient) DeleteVM(ctx context.Context, in *DeleteVMRequest, opts ...grpc.CallOption) (*VMOperationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VMOperationResponse)
	err := c.cc.Invoke(ctx, Vms_DeleteVM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vmsClient) ListVMInstance(ctx context.Context, in *ListVMInstanceReqeust, opts ...grpc.CallOption) (*ListVMInstanceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListVMInstanceResponse)
	err := c.cc.Invoke(ctx, Vms_ListVMInstance_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vmsClient) ListImage(ctx context.Context, in *ListImageRequest, opts ...grpc.CallOption) (*ListImageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListImageResponse)
	err := c.cc.Invoke(ctx, Vms_ListImage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vmsClient) DeleteImage(ctx context.Context, in *DeleteImageRequest, opts ...grpc.CallOption) (*DeleteImageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteImageResponse)
	err := c.cc.Invoke(ctx, Vms_DeleteImage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vmsClient) UpdateVM(ctx context.Context, in *UpdateVMRequest, opts ...grpc.CallOption) (*VMOperationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VMOperationResponse)
	err := c.cc.Invoke(ctx, Vms_UpdateVM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vmsClient) GetVMInfo(ctx context.Context, in *GetVMInfoRequest, opts ...grpc.CallOption) (*GetVMInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetVMInfoResponse)
	err := c.cc.Invoke(ctx, Vms_GetVMInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vmsClient) CreateVMWithMultipass(ctx context.Context, in *CreateVMWithMultipassRequest, opts ...grpc.CallOption) (*VMOperationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VMOperationResponse)
	err := c.cc.Invoke(ctx, Vms_CreateVMWithMultipass_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vmsClient) MultipassExec(ctx context.Context, in *MultipassExecRequest, opts ...grpc.CallOption) (*MultipassExecResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MultipassExecResponse)
	err := c.cc.Invoke(ctx, Vms_MultipassExec_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vmsClient) ListNode(ctx context.Context, in *ListNodeRequest, opts ...grpc.CallOption) (*ListNodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListNodeResponse)
	err := c.cc.Invoke(ctx, Vms_ListNode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vmsClient) GetNode(ctx context.Context, in *GetNodeRequest, opts ...grpc.CallOption) (*GetNodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetNodeResponse)
	err := c.cc.Invoke(ctx, Vms_GetNode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VmsServer is the server API for Vms service.
// All implementations must embed UnimplementedVmsServer
// for forward compatibility.
type VmsServer interface {
	// Libvirt
	CreateVMWithLibvirt(context.Context, *CreateVMWithLibvirtRequest) (*VMOperationResponse, error)
	CreateVolWithLibvirt(context.Context, *CreateVolWithLibvirtReqeust) (*CreateVolWithLibvirtResponse, error)
	GetVol(context.Context, *GetVolRequest) (*GetVolResponse, error)
	// rpc ListHostNetworkInterfaceWithLibvirt(ListHostNetworkInterfaceRequest) returns (ListHostNetworkInterfaceResponse);
	// rpc ListVMNetwrokInterfaceWithLibvirt(ListVMNetwrokInterfaceReqeust) returns (ListVMNetworkInterfaceResponse);
	AddNetworkInterfaceWithLibvirt(context.Context, *AddNetworkInterfaceRequest) (*VMOperationResponse, error)
	DeleteNetworkInterfaceWithLibvirt(context.Context, *DeleteNetworkInterfaceRequest) (*VMOperationResponse, error)
	AddDiskWithLibvirt(context.Context, *AddDiskRequest) (*VMOperationResponse, error)
	DeleteDiskWithLibvirt(context.Context, *DeleteDiskRequest) (*VMOperationResponse, error)
	AddHostdevWithLibvirt(context.Context, *AddHostdevRequest) (*VMOperationResponse, error)
	DeleteHostdevWithLibvirt(context.Context, *DeleteHostdevRequest) (*VMOperationResponse, error)
	GetVncPortWithLibvirt(context.Context, *VMVncPortRequest) (*VMVncPortResponse, error)
	ReinstallVMWithLibvirt(context.Context, *ReinstallVMRequest) (*VMOperationResponse, error)
	// common
	CreateVM(context.Context, *CreateVMRequest) (*VMOperationResponse, error)
	StartVM(context.Context, *StartVMRequest) (*VMOperationResponse, error)
	StopVM(context.Context, *StopVMRequest) (*VMOperationResponse, error)
	DeleteVM(context.Context, *DeleteVMRequest) (*VMOperationResponse, error)
	ListVMInstance(context.Context, *ListVMInstanceReqeust) (*ListVMInstanceResponse, error)
	ListImage(context.Context, *ListImageRequest) (*ListImageResponse, error)
	DeleteImage(context.Context, *DeleteImageRequest) (*DeleteImageResponse, error)
	// not implement now
	UpdateVM(context.Context, *UpdateVMRequest) (*VMOperationResponse, error)
	GetVMInfo(context.Context, *GetVMInfoRequest) (*GetVMInfoResponse, error)
	// Multipass
	CreateVMWithMultipass(context.Context, *CreateVMWithMultipassRequest) (*VMOperationResponse, error)
	MultipassExec(context.Context, *MultipassExecRequest) (*MultipassExecResponse, error)
	// node
	ListNode(context.Context, *ListNodeRequest) (*ListNodeResponse, error)
	GetNode(context.Context, *GetNodeRequest) (*GetNodeResponse, error)
	mustEmbedUnimplementedVmsServer()
}

// UnimplementedVmsServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedVmsServer struct{}

func (UnimplementedVmsServer) CreateVMWithLibvirt(context.Context, *CreateVMWithLibvirtRequest) (*VMOperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateVMWithLibvirt not implemented")
}
func (UnimplementedVmsServer) CreateVolWithLibvirt(context.Context, *CreateVolWithLibvirtReqeust) (*CreateVolWithLibvirtResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateVolWithLibvirt not implemented")
}
func (UnimplementedVmsServer) GetVol(context.Context, *GetVolRequest) (*GetVolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVol not implemented")
}
func (UnimplementedVmsServer) AddNetworkInterfaceWithLibvirt(context.Context, *AddNetworkInterfaceRequest) (*VMOperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddNetworkInterfaceWithLibvirt not implemented")
}
func (UnimplementedVmsServer) DeleteNetworkInterfaceWithLibvirt(context.Context, *DeleteNetworkInterfaceRequest) (*VMOperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteNetworkInterfaceWithLibvirt not implemented")
}
func (UnimplementedVmsServer) AddDiskWithLibvirt(context.Context, *AddDiskRequest) (*VMOperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddDiskWithLibvirt not implemented")
}
func (UnimplementedVmsServer) DeleteDiskWithLibvirt(context.Context, *DeleteDiskRequest) (*VMOperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteDiskWithLibvirt not implemented")
}
func (UnimplementedVmsServer) AddHostdevWithLibvirt(context.Context, *AddHostdevRequest) (*VMOperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddHostdevWithLibvirt not implemented")
}
func (UnimplementedVmsServer) DeleteHostdevWithLibvirt(context.Context, *DeleteHostdevRequest) (*VMOperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteHostdevWithLibvirt not implemented")
}
func (UnimplementedVmsServer) GetVncPortWithLibvirt(context.Context, *VMVncPortRequest) (*VMVncPortResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVncPortWithLibvirt not implemented")
}
func (UnimplementedVmsServer) ReinstallVMWithLibvirt(context.Context, *ReinstallVMRequest) (*VMOperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReinstallVMWithLibvirt not implemented")
}
func (UnimplementedVmsServer) CreateVM(context.Context, *CreateVMRequest) (*VMOperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateVM not implemented")
}
func (UnimplementedVmsServer) StartVM(context.Context, *StartVMRequest) (*VMOperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartVM not implemented")
}
func (UnimplementedVmsServer) StopVM(context.Context, *StopVMRequest) (*VMOperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopVM not implemented")
}
func (UnimplementedVmsServer) DeleteVM(context.Context, *DeleteVMRequest) (*VMOperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteVM not implemented")
}
func (UnimplementedVmsServer) ListVMInstance(context.Context, *ListVMInstanceReqeust) (*ListVMInstanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListVMInstance not implemented")
}
func (UnimplementedVmsServer) ListImage(context.Context, *ListImageRequest) (*ListImageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListImage not implemented")
}
func (UnimplementedVmsServer) DeleteImage(context.Context, *DeleteImageRequest) (*DeleteImageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteImage not implemented")
}
func (UnimplementedVmsServer) UpdateVM(context.Context, *UpdateVMRequest) (*VMOperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateVM not implemented")
}
func (UnimplementedVmsServer) GetVMInfo(context.Context, *GetVMInfoRequest) (*GetVMInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVMInfo not implemented")
}
func (UnimplementedVmsServer) CreateVMWithMultipass(context.Context, *CreateVMWithMultipassRequest) (*VMOperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateVMWithMultipass not implemented")
}
func (UnimplementedVmsServer) MultipassExec(context.Context, *MultipassExecRequest) (*MultipassExecResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MultipassExec not implemented")
}
func (UnimplementedVmsServer) ListNode(context.Context, *ListNodeRequest) (*ListNodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListNode not implemented")
}
func (UnimplementedVmsServer) GetNode(context.Context, *GetNodeRequest) (*GetNodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNode not implemented")
}
func (UnimplementedVmsServer) mustEmbedUnimplementedVmsServer() {}
func (UnimplementedVmsServer) testEmbeddedByValue()             {}

// UnsafeVmsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VmsServer will
// result in compilation errors.
type UnsafeVmsServer interface {
	mustEmbedUnimplementedVmsServer()
}

func RegisterVmsServer(s grpc.ServiceRegistrar, srv VmsServer) {
	// If the following call pancis, it indicates UnimplementedVmsServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Vms_ServiceDesc, srv)
}

func _Vms_CreateVMWithLibvirt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateVMWithLibvirtRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VmsServer).CreateVMWithLibvirt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vms_CreateVMWithLibvirt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VmsServer).CreateVMWithLibvirt(ctx, req.(*CreateVMWithLibvirtRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vms_CreateVolWithLibvirt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateVolWithLibvirtReqeust)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VmsServer).CreateVolWithLibvirt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vms_CreateVolWithLibvirt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VmsServer).CreateVolWithLibvirt(ctx, req.(*CreateVolWithLibvirtReqeust))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vms_GetVol_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VmsServer).GetVol(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vms_GetVol_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VmsServer).GetVol(ctx, req.(*GetVolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vms_AddNetworkInterfaceWithLibvirt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddNetworkInterfaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VmsServer).AddNetworkInterfaceWithLibvirt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vms_AddNetworkInterfaceWithLibvirt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VmsServer).AddNetworkInterfaceWithLibvirt(ctx, req.(*AddNetworkInterfaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vms_DeleteNetworkInterfaceWithLibvirt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteNetworkInterfaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VmsServer).DeleteNetworkInterfaceWithLibvirt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vms_DeleteNetworkInterfaceWithLibvirt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VmsServer).DeleteNetworkInterfaceWithLibvirt(ctx, req.(*DeleteNetworkInterfaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vms_AddDiskWithLibvirt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddDiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VmsServer).AddDiskWithLibvirt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vms_AddDiskWithLibvirt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VmsServer).AddDiskWithLibvirt(ctx, req.(*AddDiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vms_DeleteDiskWithLibvirt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteDiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VmsServer).DeleteDiskWithLibvirt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vms_DeleteDiskWithLibvirt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VmsServer).DeleteDiskWithLibvirt(ctx, req.(*DeleteDiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vms_AddHostdevWithLibvirt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddHostdevRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VmsServer).AddHostdevWithLibvirt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vms_AddHostdevWithLibvirt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VmsServer).AddHostdevWithLibvirt(ctx, req.(*AddHostdevRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vms_DeleteHostdevWithLibvirt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteHostdevRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VmsServer).DeleteHostdevWithLibvirt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vms_DeleteHostdevWithLibvirt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VmsServer).DeleteHostdevWithLibvirt(ctx, req.(*DeleteHostdevRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vms_GetVncPortWithLibvirt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VMVncPortRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VmsServer).GetVncPortWithLibvirt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vms_GetVncPortWithLibvirt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VmsServer).GetVncPortWithLibvirt(ctx, req.(*VMVncPortRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vms_ReinstallVMWithLibvirt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReinstallVMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VmsServer).ReinstallVMWithLibvirt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vms_ReinstallVMWithLibvirt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VmsServer).ReinstallVMWithLibvirt(ctx, req.(*ReinstallVMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vms_CreateVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateVMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VmsServer).CreateVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vms_CreateVM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VmsServer).CreateVM(ctx, req.(*CreateVMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vms_StartVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartVMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VmsServer).StartVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vms_StartVM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VmsServer).StartVM(ctx, req.(*StartVMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vms_StopVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopVMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VmsServer).StopVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vms_StopVM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VmsServer).StopVM(ctx, req.(*StopVMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vms_DeleteVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteVMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VmsServer).DeleteVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vms_DeleteVM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VmsServer).DeleteVM(ctx, req.(*DeleteVMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vms_ListVMInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListVMInstanceReqeust)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VmsServer).ListVMInstance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vms_ListVMInstance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VmsServer).ListVMInstance(ctx, req.(*ListVMInstanceReqeust))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vms_ListImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListImageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VmsServer).ListImage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vms_ListImage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VmsServer).ListImage(ctx, req.(*ListImageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vms_DeleteImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteImageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VmsServer).DeleteImage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vms_DeleteImage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VmsServer).DeleteImage(ctx, req.(*DeleteImageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vms_UpdateVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateVMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VmsServer).UpdateVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vms_UpdateVM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VmsServer).UpdateVM(ctx, req.(*UpdateVMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vms_GetVMInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVMInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VmsServer).GetVMInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vms_GetVMInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VmsServer).GetVMInfo(ctx, req.(*GetVMInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vms_CreateVMWithMultipass_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateVMWithMultipassRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VmsServer).CreateVMWithMultipass(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vms_CreateVMWithMultipass_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VmsServer).CreateVMWithMultipass(ctx, req.(*CreateVMWithMultipassRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vms_MultipassExec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MultipassExecRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VmsServer).MultipassExec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vms_MultipassExec_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VmsServer).MultipassExec(ctx, req.(*MultipassExecRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vms_ListNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VmsServer).ListNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vms_ListNode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VmsServer).ListNode(ctx, req.(*ListNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vms_GetNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VmsServer).GetNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vms_GetNode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VmsServer).GetNode(ctx, req.(*GetNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Vms_ServiceDesc is the grpc.ServiceDesc for Vms service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Vms_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Vms",
	HandlerType: (*VmsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateVMWithLibvirt",
			Handler:    _Vms_CreateVMWithLibvirt_Handler,
		},
		{
			MethodName: "CreateVolWithLibvirt",
			Handler:    _Vms_CreateVolWithLibvirt_Handler,
		},
		{
			MethodName: "GetVol",
			Handler:    _Vms_GetVol_Handler,
		},
		{
			MethodName: "AddNetworkInterfaceWithLibvirt",
			Handler:    _Vms_AddNetworkInterfaceWithLibvirt_Handler,
		},
		{
			MethodName: "DeleteNetworkInterfaceWithLibvirt",
			Handler:    _Vms_DeleteNetworkInterfaceWithLibvirt_Handler,
		},
		{
			MethodName: "AddDiskWithLibvirt",
			Handler:    _Vms_AddDiskWithLibvirt_Handler,
		},
		{
			MethodName: "DeleteDiskWithLibvirt",
			Handler:    _Vms_DeleteDiskWithLibvirt_Handler,
		},
		{
			MethodName: "AddHostdevWithLibvirt",
			Handler:    _Vms_AddHostdevWithLibvirt_Handler,
		},
		{
			MethodName: "DeleteHostdevWithLibvirt",
			Handler:    _Vms_DeleteHostdevWithLibvirt_Handler,
		},
		{
			MethodName: "GetVncPortWithLibvirt",
			Handler:    _Vms_GetVncPortWithLibvirt_Handler,
		},
		{
			MethodName: "ReinstallVMWithLibvirt",
			Handler:    _Vms_ReinstallVMWithLibvirt_Handler,
		},
		{
			MethodName: "CreateVM",
			Handler:    _Vms_CreateVM_Handler,
		},
		{
			MethodName: "StartVM",
			Handler:    _Vms_StartVM_Handler,
		},
		{
			MethodName: "StopVM",
			Handler:    _Vms_StopVM_Handler,
		},
		{
			MethodName: "DeleteVM",
			Handler:    _Vms_DeleteVM_Handler,
		},
		{
			MethodName: "ListVMInstance",
			Handler:    _Vms_ListVMInstance_Handler,
		},
		{
			MethodName: "ListImage",
			Handler:    _Vms_ListImage_Handler,
		},
		{
			MethodName: "DeleteImage",
			Handler:    _Vms_DeleteImage_Handler,
		},
		{
			MethodName: "UpdateVM",
			Handler:    _Vms_UpdateVM_Handler,
		},
		{
			MethodName: "GetVMInfo",
			Handler:    _Vms_GetVMInfo_Handler,
		},
		{
			MethodName: "CreateVMWithMultipass",
			Handler:    _Vms_CreateVMWithMultipass_Handler,
		},
		{
			MethodName: "MultipassExec",
			Handler:    _Vms_MultipassExec_Handler,
		},
		{
			MethodName: "ListNode",
			Handler:    _Vms_ListNode_Handler,
		},
		{
			MethodName: "GetNode",
			Handler:    _Vms_GetNode_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vms.proto",
}
